```xml
<extracted_text>
    <text>
        Обучающий материал по регулярным выражениям

        Что такое регулярные выражения?
    </text>
    <text>
        Регулярные выражения (или regex, от regular expressions) — это мощный инструмент для поиска и обработки текста. Они представляют собой последовательность символов, которые задают шаблон, соответствующий строкам текста. Регулярные выражения используются для выполнения операций поиска, замены, извлечения и валидации данных. Они позволяют эффективно работать с текстом и извлекать или изменять его содержимое.
    </text>
    <text>
        В языке программирования Python регулярные выражения поддерживаются через модуль re.
    </text>
    <text>
        В текстовых редакторах (например, Notepad++ и Sublime Text) регулярные выражения используются для поиска и замены текста.
    </text>
    <text>
        В языке программирования Python регулярные выражения поддерживаются через модуль re.
    </text>
    <text>
        В текстовых редакторах (например, Notepad++ и Sublime Text) регулярные выражения используются для поиска и замены текста.
    </text>
    <text>
        Мощность: они могут использоваться для выполнения сложных операций, таких как замена текста, извлечение данных и анализ структуры строки.
    </text>
    <text>
        Экономия времени: регулярные выражения позволяют автоматизировать процессы обработки текстовых данных, значительно ускоряя выполнение задач.
    </text>
    <text>
        Портативность: регулярные выражения поддерживаются во многих языках программирования и текстовых редакторах.
    </text>
    <text>
        Основные области применения регулярных выражений
    </text>
    <text>
        - Программирование: для поиска и манипуляции текстом (например, поиск чисел, замена строк).
    </text>
    <text>
        - Веб-разработка: для валидации данных (например, проверка email-адресов, телефонных номеров), а также для парсинга данных с веб-страниц.
    </text>
    <text>
        - Текстовые редакторы: для поиска и замены текста по шаблону, извлечения данных.
    </text>
    <text>
        - Анализ данных: для обработки больших объемов текстовых данных, извлечения информации.
    </text>
</extracted_text>
```

```xml
<extracted_text>
    <text>
        Основы синтаксиса регулярных выражений
    </text>
    <text>
        Точные символы
    </text>
    <text>
        Регулярные выражения могут содержать точные символы, которые будут искать совпадения с этими символами в строке.
    </text>
    <text>
        Пример: а — найдет символ "а" в строке.
    </text>
    <text>
        Квантификаторы
    </text>
    <text>
        * — 0 или более повторений (например, а* — 0 или более символов "а").
    </text>
    <text>
        + — 1 или более повторений (например, а+ — 1 или более символов "а").
    </text>
    <text>
        {n} — ровно n повторений (например, а{3} — ровно три символа "а").
    </text>
    <text>
        {n,} — минимум n повторений (например, а{2,} — два и более символа "а").
    </text>
    <text>
        {n,m} — от n до m повторений (например, а{2,4} — от двух до четырех символов "а").
    </text>
    <text>
        Символьные классы
    </text>
    <text>
        \d — цифра (аналог [0-9]).
    </text>
    <text>
        \w — буквенно-цифровой символ (аналог [a-zA-Z0-9_]).
    </text>
    <text>
        \s — пробельный символ (аналог [\t\n\r\f\v]).
    </text>
    <text>
        Примеры:
    </text>
    <text>
        \d+ — одно или более чисел.
    </text>
    <text>
        \w+ — одно или более буквенно-цифровых символов.
    </text>
    <text>
        [] — символьный класс. Допустимыми считаются символы внутри скобочек.
    </text>
    <text>
        [^] — исключающий символьный класс. Недопустимы символы в скобочках.
    </text>
    <text>
        \n — тот же символ что и n-ой группе. Например '[a-d]\1' найдет 'aa', 'bb', 'cc', 'dd'
    </text>
    <text>
        (?!...) — негативный просмотр вперед. Проверяет, что дальше не будет шаблона «...»
    </text>
    <text>
        (?&lt;!...) — негативный ретроспективный просмотр. Проверяет, что раньше не было шаблона «...»
    </text>
</extracted_text>
```

```xml
<extracted_text>
    <text>
        (?=...) — позитивный просмотр. Проверяет, что дальше будет шаблон «...»
    </text>
    <text>
        (?&lt;=...) — позитивный ретроспективный просмотр. Проверяет, что раньше был шаблон.
    </text>
    <text>
        Группировка и альтернация
    </text>
    <text>
        Группировка используется для объединения нескольких символов в одну сущность. Например: (abc) — группа символов "abc".
    </text>
    <text>
        Альтернация позволяет искать одно из нескольких возможных значений. Например: a | b — найдет либо "a", либо "b".
    </text>
    <text>
        Примеры:
    </text>
    <text>
        (abc|def) — найдет либо "abc", либо "def".
    </text>
    <text>
        (a|b)+ — найдет одну или более "a" или "b".
    </text>
    <table>
        <row>
            <coloumn> Метасимвол </coloumn>
            <coloumn> Значение </coloumn>
        </row>
        <row>
            <coloumn> . </coloumn>
            <coloumn> Соответствует любому только 1 символу </coloumn>
        </row>
        <row>
            <coloumn> [] </coloumn>
            <coloumn> Соответствует одному символу из содержащихся в квадратных скобках </coloumn>
        </row>
        <row>
            <coloumn> [-] </coloumn>
            <coloumn> Граница последовательности символов в квадратных скобках </coloumn>
        </row>
        <row>
            <coloumn> [^] </coloumn>
            <coloumn> Соответствует одному символу из не содержащихся в квадратных скобках </coloumn>
        </row>
        <row>
            <coloumn> ^ </coloumn>
            <coloumn> Соответствует началу строки </coloumn>
        </row>
        <row>
            <coloumn> $ </coloumn>
            <coloumn> Соответствует концу строки </coloumn>
        </row>
        <row>
            <coloumn> * </coloumn>
            <coloumn> Соответствует 0 или более предыдущих элементов </coloumn>
        </row>
        <row>
            <coloumn> ? </coloumn>
            <coloumn> Соответствует 0 или одну предыдущему элементу </coloumn>
        </row>
        <row>
            <coloumn> + </coloumn>
            <coloumn> Означает, что предшествующий символ присутствует и может повторяться несколько раз </coloumn>
        </row>
        <row>
            <coloumn> | </coloumn>
            <coloumn> Операция ИЛИ: соответствует либо выражению до операции, либо выражению после нее </coloumn>
        </row>
        <row>
            <coloumn> \ </coloumn>
            <coloumn> Символ литерализации. Позволяет использовать для составления любой метасимвол как литерал (экранирование специальных символов) </coloumn>
        </row>
        <row>
            <coloumn> () </coloumn>
            <coloumn> Группирует символы в подстроки </coloumn>
        </row>
        <row>
            <coloumn> {} </coloumn>
            <coloumn> Количество повторений предыдущего символа </coloumn>
        </row>
    </table>
</extracted_text>
```

```xml
<extracted_text>
    <text>
        Практическое использование регулярных выражений
    </text>
    <text>
        Регулярные выражения часто используются в программировании для поиска, замены и извлечения данных. Рассмотрим пример на Python и PascalABC.NET:
    </text>
    <text>
        import re
    </text>
    <text>
        pattern = r'\d+' # шаблон для поиска всех чисел text = "У меня есть 123 яблока и 456 апельсинов."
    </text>
    <text>
        matches = re.findall(pattern, text)
    </text>
    <text>
        print(matches) # Output: ['123', '456']
    </text>
    <text>
        ## var pattern := '\d+';
    </text>
    <text>
        var s := 'У меня есть 123 яблока и 456 апельсинов';
    </text>
    <text>
        var matches := Regex.Matches(s, pattern);
    </text>
    <text>
        print(matches)
    </text>
    <text>
        В этом примере регулярное выражение \d+ находит все последовательности цифр в строке.
    </text>
    <text>
        Применение в текстовых редакторах
    </text>
    <text>
        Многие текстовые редакторы, такие как Notepad++ и Sublime Text, поддерживают регулярные выражения для поиска и замены текста. Например, в Notepad++ можно использовать регулярное выражение для поиска всех email-адресов:
    </text>
    <text>
        [a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,}
    </text>
    <text>
        Это регулярное выражение находит все email-адреса в тексте.
    </text>
    <text>
        Использование в валидации данных
    </text>
    <text>
        Регулярные выражения также часто используются для валидации данных, введенных пользователем. Например, для проверки правильности ввода email-адреса можно использовать следующее регулярное выражение:
    </text>
    <text>
        [a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,}
    </text>
    <text>
        Это регулярное выражение проверяет, что введенный текст является корректным email-адресом.
    </text>
</extracted_text>
```

```xml
<extracted_text>
    <text>
        Регулярные выражения в PascalABC.NET
    </text>
    <text>
        В языке PascalABC.NET имеются следующие основные методы для работы с классом Regex:
    </text>
    <text>
        - Regex.IsMatch - возвращает Boolean (true/false) в зависимости от того найдено ли выражение в строке
    </text>
    <text>
        ## var s := 'Маша мыла раму';
    </text>
    <text>
        var b := Regex.IsMatch(s, '\d+');
    </text>
    <text>
        println(b); // output: False
    </text>
    <text>
        Объяснение: регулярное выражение \d+ находит какую-нибудь последовательность чисел. Чисел в строке нет, значит результат — ложь.
    </text>
    <text>
        - Regex.Match - возвращает первое найденное выражение
    </text>
    <text>
        ## var s := 'Маша мыла раму';
    </text>
    <text>
        var b := Regex.Match(s, 'м[б-я^у]');
    </text>
    <text>
        println(b); // output: мы
    </text>
    <text>
        Объяснение: регулярное выражение м[б-я^у] ищет сочетание из двух букв, из которых первая — м, а вторая — какая то из букз промежутка от б до я, кроме у (исключающий класс).
    </text>
    <text>
        - Regex.Matches - возвращает все найденные выражения
    </text>
    <text>
        ## var s := 'Маша мыла маму';
    </text>
    <text>
        var b := Regex.Matches(s, 'м[а-я]+', RegexOptions.IgnoreCase);
    </text>
    <text>
        println(b); // output: [Маша, мы, маму]
    </text>
    <text>
        Объяснение: это регулярное выражение ищет последовательности из пар букв «М» с какой то любой другой буквой от «а» до «я».
    </text>
</extracted_text>
```

```xml
<extracted_text>
    <text>
        - Regex.Split - разбивает строку на фрагменты; разделители фрагментов определяются регулярным выражением
    </text>
    <text>
        ## var s := 'sk123ibidi dollp dop ye033s';
    </text>
    <text>
        var b := Regex.Split(s, '\d+', RegexOptions.IgnoreCase);
    </text>
    <text>
        println(b); // output: [sk,ibidi do,p dop ye,s]
    </text>
    <text>
        Объяснение: это регулярное выражение находит последовательности из цифр. Таким образом, эти последовательности служат разделителями.
    </text>
    <text>
        - Regex.Replace - заменяет найденные выражения
    </text>
    <text>
        ## var s := 'sk123ibidi dollp dop ye033s';
    </text>
    <text>
        var b := Regex.Replace(s, '\d+', '', RegexOptions.IgnoreCase);
    </text>
    <text>
        println(b); // output: skibidi dollp dop yes
    </text>
    <text>
        Объяснение: это регулярное выражение находит последовательности из цифр. Эти цифры затем заменяются на "" — то есть отсутствие символа
    </text>
    <text>
        Решение задач ЕГЭ с помощью RegEx
    </text>
    <text>
        Некоторые задачи из ЕГЭ можно очень удобно и быстро решать регулярными выражениями. Ниже будут приведены 18 задач типа 24. Обычно идеи в таких задачах не слишком замудренные и нужно лишь привести данные в удобный вид и применить соответствующее вопросу задачи регулярное выражение.
    </text>
    <text>
        Все семплы данных можно скачать по этой ссылке: https://drive.google.com
    </text>
    <text>
        В конце документа вы сможете найти их решения на PascalABC.NET.
    </text>
</extracted_text>
```

```xml
<extracted_text>
    <text>
        №1 В текстовом файле k7a-2.txt находится цепочка из символов латинского алфавита A, B, C, D, E, F. Найдите длину самой длинной подцепочки, состоящей из символов A, C, D (в произвольном порядке).
    </text>
    <text>
        Разбор решения
    </text>
    <text>
        - Нам подходят из всех символов только А С и D. Значит нам нужно обозначить их в символьном классе.
    </text>
    <text>
        - наше регулярное выражение выглядит так '[ACD]+'. Теперь просто найдем все нужные нам цепочки и выберем самую длинную.
    </text>
    <text>
        ## var pattern := '[ACD]+';
    </text>
    <text>
        var ms := Regex.Matches(s, pattern);
    </text>
    <text>
        var maxlen := 0;
    </text>
    <text>
        for var i:=0 to ms.Count-1 do begin if(ms[i].Length > maxlen) then maxlen := ms[i].Length; end;
    </text>
    <text>
        println(maxlen);
    </text>
    <text>
        №2 В текстовом файле k7a-6.txt находится цепочка из символов латинского алфавита A, B, C, D, E, F. Найдите длину самой длинной подцепочки, не содержащей гласных букв.
    </text>
    <text>
        №3 В текстовом файле k7c-6.txt находится цепочка из символов латинского алфавита A, B, C, D, E, F. Найдите количество цепочек длины 3, в которых символы не совпадают.
    </text>
    <text>
        Разбор решения
    </text>
    <text>
        - Первым делом необходимо составить регулярное выражение. Первый символ должен быть от A до F, а следующий за ним не должен быть таким же как данный символ. Здесь удобно использовать?
    </text>
</extracted_text>
```

```xml
<extracted_text>
    <text>
        - Негативный просмотр вперед! Теперь выражение выглядит так &lt;([A-F])(?!\1)[A-F]&gt;. Теперь нужно продолжить его составление для 2 оставшихся символов тройки.
    </text>
    <text>
        &lt;([A-F])(?!\1)([A-F])(?!\1|\2)([A-F])&gt; - искомое выражение.
    </text>
    <text>
        ## var pattern := '([A-F])(?!\1)([A-F])(?!\1|\2)([A-F])';
    </text>
    <text>
        var ms := Regex.Matches(s, pattern);
    </text>
    <text>
        println(ms);
    </text>
    <text>
        №4 В текстовом файле k8-18.txt находится цепочка из символов, в которую могут входить заглавные буквы латинского алфавита A...Z и десятичные цифры. Найдите длину самой длинной подцепочки, состоящей из одинаковых символов. Если в файле несколько подходящих цепочек одинаковой длины, нужно взять первую из них. Выведите сначала символ, из которого строится эта подцепочка, а затем через пробел — длину этой подцепочки.
    </text>
    <text>
        №5 Текстовый файл 24-1.txt состоит не более чем из 106 символов. Определите максимальное нечетное число, записанное в этом файле. Под числом подразумевается последовательность цифр, ограниченная другими символами (не цифрами).
    </text>
    <text>
        Важно понимать, что не все задачи типа 24 можно решить регулярными выражениями. Рассмотрим следующую задачу:
    </text>
    <text>
        Текстовый файл 24.txt содержит последовательность из строчных и заглавных букв английского алфавита и цифр, всего не более 106 символов. Определите длину наибольшей возрастающей подпоследовательности. Возрастающей подпоследовательностью будем называть непрерывную последовательность символов, расположенных в порядке увеличения их номера в кодовой таблице символов ASCII.
    </text>
    <text>
        Регулярки позволяют выбирать строки подхолящие шаблону, однако этот шаблон должен быть фиксированным. В данном случае с возрастающей последовательностью мы не можем придумать какой-либо паттерн.
    </text>
</extracted_text>
```

```xml
<extracted_text>
    <text>
        Эту задачу легче решить обыкновенным перебором строки. Вот пример решения на Python:
    </text>
    <text>
        # Читаем файл
    </text>
    <text>
        with open("24.txt", "r") as file: content = file.read().strip()
    </text>
    <text>
        max_length = 1
    </text>
    <text>
        current_length = 1
    </text>
    <text>
        # Проходим по строке
    </text>
    <text>
        for i in range(1, len(content)): # Проверяем по ASCII-колу if ord(content[i]) &gt; ord(content[i - 1]): current_length += 1 # Продолжаем последовательность max_length = max(max_length, current_length) # Обновляем максимум else: current_length = 1 # Начинаем новую последовательность
    </text>
    <text>
        # Выводим результат print(max_length)
    </text>
    <text>
        №6 Текстовый файл 24-J1.txt состоит не более чем из 106 кириллических символов К, О, Т. Определите максимальное количество подряд идущих комбинаций КОТ.
    </text>
    <text>
        №7 Текстовый файл 24-J4.txt состоит не более чем из 106 символов J, O, B, S. Сколько раз встречаются комбинации «BOSS» при этом до и после этого слова нет символа «І». Например, комбинации «IBOSS», «BOSSІ» и «JBOSSJ» не должны учитываться.
    </text>
    <text>
        №8 Текстовый файл 24-J7.txt состоит не более чем из 106 десятичных цифр. Найдите максимальную длину последовательности, которая состоит из цифр одинаковой четности. Например, в последовательности 1533244622185452354, 5 последовательностей с нечетными цифрами — 1533, 1, 5, 35 — и 5 с четными — 244622, 8, 4, 2, 4. Следовательно, искомая
    </text>
</extracted_text>
```

```xml
<extracted_text>
    <text>
        последовательность — 244622. В качестве ответа укажите максимальную длину найденной последовательности.
    </text>
    <text>
        №9 Текстовый файл 24-j9.txt состоит не более чем из 106 символов английского алфавита. Определите количество палиндромов (последовательностей, которые читаются в обе стороны одинаково) длиной 5 символов.
    </text>
    <text>
        №10 Текстовый файл 24-153.txt содержит строку из заглавных букв A, B, C, D, E, F, всего не более 106 символов. D-подстроками назовём последовательности идущих подряд символов D, ограниченные иными символами и/или границами строки. Определите минимальную длину D-подстроки.
    </text>
    <text>
        №11 Текстовый файл 24-153.txt содержит строку из заглавных букв A, B, C, D, E, F, всего не более 106 символов. AF-подстроками назовём непустые последовательности идущих подряд символов A, B, C, D, E, F, ограниченные в начале символом А, а в конце символом F (граничные символы входят в подстроку). Определите количество AF-подстрок длиной от 7 до 10 символов.
    </text>
    <text>
        №12 Текстовый файл 24-180. txt содержит строку из десятичных цифр, всего не более чем из 106 символов. Файл образовался в результате последовательной записи «таймкодов» некоторых событий в формате HHMM (часы и минуты слитно по две цифры, т.е. всего 4 цифры на «таймкод»), от 0000 до 2359) и прочих случайных данных. Найдите максимально возможное количество подряд идущих «таймкодов» между фрагментами случайной информации. Например, в строке 4212231135414447 можно выделить таймкоды тремя способами: 4[2122]3[1135]4[1444]7, 42[1223,1135]4[1444]7 или 421[2231, 1354, 1444]7. В последнем случае получилось наибольшее количество таймкодов подряд (3), это число и нужно ввести в ответе.
    </text>
</extracted_text>
```

```xml
<extracted_text>
    <text>
        №13 Текстовый файл 24-181.txt содержит строку из заглавных латинских букв и точек, всего не более чем из 106 символов. Определите максимальное количество идущих подряд символов, среди которых нет букв Y, а количество точек не превышает 5.
    </text>
    <text>
        №14 Текстовый файл 24-181.txt содержит строку из заглавных латинских букв и точек, всего не более чем из 106 символов. Определите максимальное количество идущих подряд символов, среди которых нет точек, а количество гласных (букв A, E, I, O, U, Y) не превышает 7.
    </text>
    <text>
        №15 Текстовый файл 24-191. txt содержит строку из заглавных латинских букв, всего не более чем из 106 символов. Определите количество подстрок длиной не более 12 символов, которые начинаются и заканчиваются буквой А и не содержат других букв А (кроме первой и последней) и букв В.
    </text>
    <text>
        №16 Текстовый файл 24-191. txt содержит строку из заглавных латинских букв, всего не более чем из 106 символов. Определите количество подстрок длиной не более 15 символов, которые начинаются буквой А, содержат букву F, заканчиваются буквой В и не содержат других букв А и В, кроме первой и последней.
    </text>
    <text>
        №17 Текстовый файл 24-197.txt содержит строку из заглавных латинских букв X, Y и Z, всего не более чем из 106 символов. Определите максимальное количество идущих подряд троек символов ZXY или ZYX.
    </text>
    <text>
        №18 Текстовый файл 24-204.txt содержит строку из заглавных латинских букв A, B и C, всего не более чем из 106 символов. Найдите максимальное количество подряд идущих пар символов АА или СС. Искомая подстрока может включать только пары АА, только пары СС или содержать одновременно как пары АА, так и пары СС.
    </text>
</extracted_text>
```